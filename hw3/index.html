<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Summer 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Jake Pastoria</div>

		<br>

		<br>

		Link to main webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-Jake-Pastoria/">https://cal-cs184.github.io/hw-webpages-su25-Jake-Pastoria/</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw-pathtracer-updated-jp">https://github.com/cal-cs184/hw-pathtracer-updated-jp</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>
		In Part 1, I implemented ray generation and ray-triangle/ray-circle intersection, which allows the most basic ray tracing. I began this process by generating rays that convert coordinates 
		in the Image Space into a Ray in the camera space. This ray is defined by the ray equation: 
		
		\[r(t) = o + td\]

		Here, \(o\) is the origin of the ray, \(d\) is the direction (a 3-dimensional vector) that the ray points, and \(t\) is the time/distance along the vector \(d\) starting from \(o\).
		In the camera space, we define this "Camera Ray" to originate from \(o = (0,0,0)\), and point towards the "sensor" of the camera which is located at \(z = -1\). Finally, we can 
		rotate this ray into the world space and place it at the camera's position, which places the ray into our scene.

		<br><br>

		To fill in each pixel on the screen, we generate numerous rays per pixel, and simply find the average scene radiance along those rays. For this beginning section, the estimated radiance 
		along any given ray is simply either the direction that the ray points or the normal of the object it hits. All of the work so far results in the following image:

		<figure>
			<img src="p1_1.png" alt="Cornell Boxes with Bunnies" style="width:50%"/>
			<figcaption>banana.dae</figcaption>
		</figure>


		The next step is to implement ray-triangle and ray-circle intersections, and for circles, the solutions for the intersections can be easily calculated by plugging in the ray equation to the 
		circle equation. Ray-triangle intersection is significantly more difficult, as this involves multiple steps in order to detect collisions. My method first calculates if the ray intersects 
		with the plane that the triangle lays inside of. If there is an intersection with the plane, I find the value of \(t\) where this intersection happens. As long as this t is in between the 
		predefined minimum and maximums, we now need to determine whether this point lies inside of the triangle. To do this, I used the geometric interpretation of the Barycentric coordinate 
		system, which involves finding the proportional areas of \(	α\), \(	β\), and \(γ\). Using these three values, we can tell if the ray intersects inside the triangle by making sure that 
		these three values are all greater than 0 (in addition to some other checks to make sure we don't include points outside the edges of the triangle). 

		<br><br>

		Here are the renders generated using the previously described methods:
		<br><br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="p1_2.png" width="400px"/>
				  
				</td>
				<td style="text-align: center;">
				  <img src="p1_3.png" width="400px"/>
				  
				</td>
			</table>
		</div>
		<figure>
			<img src="p1_4.png" alt="Cornell Boxes with Bunnies" style="width:400px"/>
		
		</figure>
		
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		We can use a Bounding Volume Hierarchy (BVH) to optimize our ray tracing by grouping together primitives and creating combined bounding boxes. This Hierarchy is a binary tree, with each node 
		pointing to its left and right sub-nodes that either contain more connections or are leaf nodes. This process starts by taking in a list of all the primitives and generating a root node 
		with a bounding box that contains all the primitives. 
		<br><br>
		From there, we need to establish a heuristic for where to split our bounding box and continue creating the sub-nodes. 
		My method finds the axis (\(x\), \(y\), or \(z\)) that contains the largest extent (the largest difference between the min and max), as this essentially means it has the most variance.
		 This method assumes that the dimension with the most variance captures the most information about our mesh (similar to the thought process of Principal Component Analysis) and are 
		therefore the best to split across. After finding the mean of the centroids of all the primitives bounding boxes along this axis, I split at that value.
		<br><br>
		We can use this BVH to vastly decrease the rendering team needed for each dae file. Here are some examples of highly complex .dae files:
		<br><br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="p2_1.png" width="400px"/>
				  <figcaption>cow.dae</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="p2_2.png" width="400px"/>
				  <figcaption>lucy.dae</figcaption>
				</td>
			  </tr>
			  </table>
		</div>
		<figure>
			<img src="p2_3.png" alt="Cornell Boxes with Bunnies" style="width:400px"/>
			<figcaption>maxplanck.dae</figcaption>
		</figure>

		The BVH has reduced the computational load from \(O(n)\) to \(O(log(n))\), which results in drastic differences in rendering times for scenes with moderately and highly complex meshes. 
		We an explore this time reduction for moderately complex meshes, such as cow.dae. Without using a BVH, this image below takes 44.05 seconds to redner. After adding the BVH, the rendering 
		time drastically drops to 0.25 seconds: <br> <br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="p2_4.png" width="400px"/>
				  <figcaption>cow.dae w/o BVH (44.05 seconds)</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="p2_5.png" width="400px"/>
				  <figcaption>cow.dae w/ BVH (0.25 seconds)</figcaption>
				</td>
			  </tr>
			  </table>
		</div>

		<br> <br>
		This speed increase is similar for all moderately complex scenes, such as beetle.dae. We can see that rendering without the BVH takes 58.9 seconds, while rendering with takes about 0.3 
		seconds. 
		<br> <br>


		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="p2_6.png" width="400px"/>
				  <figcaption>beetle.dae w/o BVH (58.9 seconds)</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="p2_7.png" width="400px"/>
				  <figcaption>beetle.dae w/ BVH (0.3 seconds)</figcaption>
				</td>
			  </tr>
			  </table>
		</div>

		<br> <br>
		Due to the BVH, each ray no longer needs to check every primitive during rendering, significantly reducing the computational load of ray tracing. The bounding boxes 
		define the potential region in which any enclosed primitive could be hit, allowing us to quickly eliminate primitives that the ray couldn't possibly intersect.


		<h2>Part 3: Direct Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 4: Global Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>